// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// BETTER AUTH CORE MODELS
// ============================================

model User {
  id               String        @id @default(cuid())
  name             String?
  email            String        @unique
  emailVerified    Boolean       @default(false)
  image            String?
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  // subscription
  subscription     Subscription?
  // Better Auth Admin Plugin Fields
  role             String        @default("customer") // customer, admin, manager
  banned           Boolean       @default(false)
  banReason        String?
  banExpires       DateTime?
  // Two-Factor Authentication
  twoFactorEnabled Boolean       @default(false)
  // CinemaX specific fields (extending Better Auth)
  firstName        String?
  lastName         String?
  phoneNumber      String?
  isActive         Boolean       @default(true)

  // Relations
  sessions     Session[]
  accounts     Account[]
  bookings     Booking[]
  reviews      Review[]
  WatchHistory WatchHistory[]
  watchParties WatchParty[] @relation("HostWatchParties")
  comments     MovieComment[]
  seriesReviews      SeriesReview[]
  seriesWatchHistories SeriesWatchHistory[]
  episodeWatchHistories EpisodeWatchHistory[]
  seriesComments     SeriesComment[]
  episodeComments    EpisodeComment[]
  seriesWatchParties SeriesWatchParty[] @relation("HostSeriesWatchParties")

  @@map("user")
}

model Session {
  id        String   @id @default(cuid())
  expiresAt DateTime
  token     String   @unique
  ipAddress String?
  userAgent String?
  userId    String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Better Auth Admin Plugin Field
  impersonatedBy String? // ID of admin impersonating this session

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id @default(cuid())
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String    @id @default(cuid())
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt

  @@map("verification")
}

// ============================================
// CINEMA & THEATER MANAGEMENT
// ============================================

model Cinema {
  id       String  @id @default(cuid())
  name     String
  address  String
  city     String
  state    String?
  zipCode  String?
  phone    String?
  isActive Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  theaters Theater[]

  @@map("cinemas")
}

model Theater {
  id         String     @id @default(cuid())
  name       String // e.g., "Theater 1", "IMAX Hall"
  cinemaId   String
  totalSeats Int
  screenType ScreenType @default(STANDARD)
  isActive   Boolean    @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  cinema    Cinema     @relation(fields: [cinemaId], references: [id], onDelete: Cascade)
  seats     Seat[]
  showtimes Showtime[]

  @@map("theaters")
}

model Seat {
  id        String   @id @default(cuid())
  theaterId String
  row       String // A, B, C, etc.
  number    Int // 1, 2, 3, etc.
  seatType  SeatType @default(STANDARD)
  isActive  Boolean  @default(true)

  // Relations
  theater          Theater           @relation(fields: [theaterId], references: [id], onDelete: Cascade)
  bookingSeats     BookingSeat[]
  tempReservations TempReservation[]

  @@unique([theaterId, row, number])
  @@map("seats")
}

enum ScreenType {
  STANDARD
  IMAX
  DOLBY_ATMOS
  FOUR_DX
}

enum SeatType {
  STANDARD
  PREMIUM
  VIP
  WHEELCHAIR_ACCESSIBLE
}

// ============================================
// MOVIE MANAGEMENT
// ============================================

model Movie {
  id           String    @id @default(cuid())
  title        String
  slug         String    @unique // URL-friendly version of title
  streamingUrl String? // URL for streaming the movie (if available)
  description  String?
  duration     Int // in minutes
  genre        String[]
  rating       String? // PG, PG-13, R, etc.
  director     String?
  cast         String[] // Array of actor names
  posterUrl    String? // Portrait format (2:3) for cards/thumbnails
  backdropUrl  String? // Landscape format (16:9) for hero sections
  trailerUrl   String?
  releaseDate  DateTime?
  isActive     Boolean   @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  showtimes    Showtime[]
  reviews      Review[]
  WatchHistory WatchHistory[]
  watchParties WatchParty[]
  aiTrailers   AiTrailer[]

  @@map("movies")
}

// ============================================
// SHOWTIME MANAGEMENT
// ============================================

model Showtime {
  id        String   @id @default(cuid())
  movieId   String
  theaterId String
  startTime DateTime
  endTime   DateTime
  basePrice Decimal  @db.Decimal(10, 2)
  isActive  Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  movie            Movie             @relation(fields: [movieId], references: [id], onDelete: Cascade)
  theater          Theater           @relation(fields: [theaterId], references: [id], onDelete: Cascade)
  bookings         Booking[]
  tempReservations TempReservation[]

  // Constraint: No overlapping showtimes in same theater
  @@unique([theaterId, startTime])
  @@map("showtimes")
}

// ============================================
// BOOKING MANAGEMENT
// ============================================

model Booking {
  id              String        @id @default(cuid())
  userId          String
  showtimeId      String
  bookingNumber   String        @unique // e.g., "CMX-2024-001234"
  totalAmount     Decimal       @db.Decimal(10, 2)
  bookingFee      Decimal       @default(0) @db.Decimal(10, 2)
  status          BookingStatus @default(PENDING)
  paymentIntentId String? // Stripe payment intent ID
  qrCode          String? // Generated QR code for ticket verification

  // Timestamps
  bookingDate DateTime  @default(now())
  expiresAt   DateTime? // For pending bookings
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  user         User          @relation(fields: [userId], references: [id])
  showtime     Showtime      @relation(fields: [showtimeId], references: [id])
  bookingSeats BookingSeat[]
  payment      Payment?
  survey       Survey?

  @@map("bookings")
}

model BookingSeat {
  id        String  @id @default(cuid())
  bookingId String
  seatId    String
  price     Decimal @db.Decimal(10, 2)

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  seat    Seat    @relation(fields: [seatId], references: [id])

  @@unique([bookingId, seatId])
  @@map("booking_seats")
}

// Temporary reservations to handle race conditions during booking
model TempReservation {
  id         String   @id @default(cuid())
  seatId     String
  showtimeId String
  sessionId  String // Frontend session ID
  expiresAt  DateTime
  createdAt  DateTime @default(now())

  // Relations
  seat     Seat     @relation(fields: [seatId], references: [id], onDelete: Cascade)
  showtime Showtime @relation(fields: [showtimeId], references: [id], onDelete: Cascade)

  @@unique([seatId, showtimeId])
  @@map("temp_reservations")
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  EXPIRED
  REFUNDED
}

// ============================================
// PAYMENT MANAGEMENT
// ============================================

model Payment {
  id              String        @id @default(cuid())
  bookingId       String        @unique
  stripePaymentId String        @unique // Stripe payment intent ID
  amount          Decimal       @db.Decimal(10, 2)
  currency        String        @default("USD")
  status          PaymentStatus @default(PENDING)
  paymentMethod   String? // card, apple_pay, google_pay, etc.
  refundAmount    Decimal?      @db.Decimal(10, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("payments")
}

enum PaymentStatus {
  PENDING
  SUCCEEDED
  FAILED
  CANCELLED
  REFUNDED
}

// ============================================
// SUBSCRIPTION & CREDITS SYSTEM
// ============================================
model Subscription {
  id               String             @id @default(cuid())
  userId           String             @unique
  plan             SubscriptionPlan
  status           SubscriptionStatus
  currentPeriodEnd DateTime
  credits          Int                @default(0) // optional, for bundled credits
  startedAt        DateTime           @default(now())
  canceledAt       DateTime?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  // Relations
  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  watchHistory     WatchHistory[]
  creditEvents     CreditEvent[]
  seriesWatchHistories SeriesWatchHistory[]
  episodeWatchHistories EpisodeWatchHistory[]

  @@map("subscriptions")
}

enum SubscriptionPlan {
  MONTHLY
  YEARLY
  
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
}

model WatchHistory {
  id             String        @id @default(cuid())
  userId         String
  movieId        String
  progress       Float // 0.0 - 1.0 (fraction watched)
  completed      Boolean       @default(false)
  completedAt    DateTime?
  startedAt      DateTime      @default(now())
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  // Relations
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  movie          Movie         @relation(fields: [movieId], references: [id], onDelete: Cascade)
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String? // optional: to relate to subscription

  @@unique([userId, movieId])
  @@map("watch_histories")
}

model CreditEvent {
  id             String          @id @default(cuid())
  subscriptionId String
  type           CreditEventType
  amount         Int
  description    String?
  createdAt      DateTime        @default(now())
  // Relations
  subscription   Subscription    @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@map("credit_events")
}

enum CreditEventType {
  GRANT
  DEDUCT
  EXPIRE
  MANUAL
}

// ============================================
// REVIEW & FEEDBACK SYSTEM
// ============================================

model Review {
  id         String  @id @default(cuid())
  userId     String
  movieId    String
  rating     Int // 1-5 stars
  comment    String?
  isApproved Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user  User  @relation(fields: [userId], references: [id])
  movie Movie @relation(fields: [movieId], references: [id])

  @@unique([userId, movieId])
  @@map("reviews")
}

model Survey {
  id                      String    @id @default(cuid())
  bookingId               String    @unique
  overallRating           Int? // 1-5 stars
  bookingExperienceRating Int? // 1-5 stars
  theaterExperienceRating Int? // 1-5 stars
  wouldRecommend          Boolean?
  comments                String?
  emailSent               Boolean   @default(false)
  completedAt             DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  booking Booking @relation(fields: [bookingId], references: [id])

  @@map("surveys")
}

// ============================================
// SYSTEM CONFIGURATION
// ============================================

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_configs")
}

// ============================================
// WATCH PARTY SYSTEM
// ============================================

model WatchParty {
  id           String   @id @default(cuid())
  hostUserId   String
  movieId      String
  createdAt    DateTime @default(now())
  expiresAt    DateTime?
  isActive     Boolean  @default(true)
  maxGuests    Int      @default(5)

  // Relations
  host         User     @relation("HostWatchParties", fields: [hostUserId], references: [id], onDelete: Cascade)
  movie        Movie    @relation(fields: [movieId], references: [id], onDelete: Cascade)

  @@map("watch_parties")
}

// ============================================
// AI TRAILER SYSTEM
// ============================================

model AiTrailer {
  id          String           @id @default(cuid())
  movieId     String
  script      String           // The OpenAI generated script
  fileUrl     String           // S3 URL for the audio file
  fileSize    Int              // File size in bytes
  voiceStyle  String           // Voice style used (e.g., "epic", "dramatic")
  status      AiTrailerStatus  @default(PENDING)
  errorMessage String?         // Error message if generation failed
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  createdBy   String?          // User ID who created the trailer

  // Relations
  movie       Movie            @relation(fields: [movieId], references: [id], onDelete: Cascade)

  @@map("ai_trailers")
}

enum AiTrailerStatus {
  PENDING
  GENERATING_SCRIPT
  GENERATING_AUDIO
  UPLOADING
  COMPLETED
  FAILED
}

// ============================================
// MOVIE COMMENTS SYSTEM
// ============================================

model MovieComment {
  id         String   @id @default(cuid())
  movieSlug  String
  userId     String
  userName   String
  userAvatar String?
  content    String
  isSpoiler  Boolean  @default(false)
  parentId   String?  // For reply threading
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  parent MovieComment? @relation("CommentReplies", fields: [parentId], references: [id])
  replies MovieComment[] @relation("CommentReplies")

  @@map("movie_comments")
}

// ============================================
// TV SERIES MANAGEMENT
// ============================================

model Series {
  id           String    @id @default(cuid())
  title        String
  slug         String    @unique // URL-friendly version of title
  description  String?
  genres       String[]  // Array of genre names
  releaseYear  Int?
  coverUrl     String?   // Main cover/poster image
  backdropUrl  String?   // Landscape background image
  cast         String[]  // Array of actor names
  director     String?   // Main director or showrunner
  rating       String?   // TV rating (TV-14, TV-MA, etc.)
  isActive     Boolean   @default(true)
  isPublished  Boolean   @default(false) // For scheduling releases
  publishedAt  DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  seasons      Season[]
  reviews      SeriesReview[]
  WatchHistory SeriesWatchHistory[]
  comments     SeriesComment[]
  watchParties SeriesWatchParty[]

  @@map("series")
}

model Season {
  id          String   @id @default(cuid())
  seriesId    String
  number      Int      // Season number (1, 2, 3, etc.)
  title       String?  // Optional season title (e.g., "Season 1: The Beginning")
  description String?  // Season description
  releaseDate DateTime?
  coverUrl    String?  // Optional season-specific cover
  isActive    Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  series   Series    @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  episodes Episode[]

  @@unique([seriesId, number])
  @@map("seasons")
}

model Episode {
  id          String   @id @default(cuid())
  seasonId    String
  number      Int      // Episode number within season
  title       String
  description String?
  videoUrl    String?  // Streaming URL for the episode
  runtime     Int      // Duration in minutes
  coverUrl    String?  // Episode thumbnail/cover
  airDate     DateTime?
  isActive    Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  season       Season              @relation(fields: [seasonId], references: [id], onDelete: Cascade)
  WatchHistory EpisodeWatchHistory[]
  comments     EpisodeComment[]

  @@unique([seasonId, number])
  @@map("episodes")
}

// ============================================
// SERIES-SPECIFIC FEATURES
// ============================================

model SeriesReview {
  id         String  @id @default(cuid())
  userId     String
  seriesId   String
  rating     Int     // 1-5 stars
  comment    String?
  isApproved Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user   User   @relation(fields: [userId], references: [id])
  series Series @relation(fields: [seriesId], references: [id])

  @@unique([userId, seriesId])
  @@map("series_reviews")
}

model SeriesWatchHistory {
  id         String    @id @default(cuid())
  userId     String
  seriesId   String
  progress   Float     // 0.0 - 1.0 (fraction watched of the entire series)
  completed  Boolean   @default(false)
  completedAt DateTime?
  startedAt  DateTime  @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  series         Series        @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String? // optional: to relate to subscription

  @@unique([userId, seriesId])
  @@map("series_watch_histories")
}

model EpisodeWatchHistory {
  id         String    @id @default(cuid())
  userId     String
  episodeId  String
  progress   Float     // 0.0 - 1.0 (fraction watched)
  completed  Boolean   @default(false)
  completedAt DateTime?
  startedAt  DateTime  @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  episode        Episode       @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])
  subscriptionId String? // optional: to relate to subscription

  @@unique([userId, episodeId])
  @@map("episode_watch_histories")
}

model SeriesComment {
  id         String   @id @default(cuid())
  seriesId   String
  userId     String
  userName   String
  userAvatar String?
  content    String
  isSpoiler  Boolean  @default(false)
  parentId   String?  // For reply threading
  createdAt  DateTime @default(now())

  // Relations
  user     User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  series   Series         @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  parent   SeriesComment? @relation("SeriesCommentReplies", fields: [parentId], references: [id])
  replies  SeriesComment[] @relation("SeriesCommentReplies")

  @@map("series_comments")
}

model EpisodeComment {
  id         String   @id @default(cuid())
  episodeId  String
  userId     String
  userName   String
  userAvatar String?
  content    String
  isSpoiler  Boolean  @default(false)
  parentId   String?  // For reply threading
  createdAt  DateTime @default(now())

  // Relations
  user     User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  episode  Episode         @relation(fields: [episodeId], references: [id], onDelete: Cascade)
  parent   EpisodeComment? @relation("EpisodeCommentReplies", fields: [parentId], references: [id])
  replies  EpisodeComment[] @relation("EpisodeCommentReplies")

  @@map("episode_comments")
}

model SeriesWatchParty {
  id           String   @id @default(cuid())
  hostUserId   String
  seriesId     String
  episodeId    String?  // Optional: focus on specific episode
  createdAt    DateTime @default(now())
  expiresAt    DateTime?
  isActive     Boolean  @default(true)
  maxGuests    Int      @default(5)

  // Relations
  host    User   @relation("HostSeriesWatchParties", fields: [hostUserId], references: [id], onDelete: Cascade)
  series  Series @relation(fields: [seriesId], references: [id], onDelete: Cascade)

  @@map("series_watch_parties")
}
